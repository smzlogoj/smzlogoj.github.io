[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tumbleweed",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "rnaseq/deseq/introduccion.html",
    "href": "rnaseq/deseq/introduccion.html",
    "title": "Análisis de expresión diferencial",
    "section": "",
    "text": "Podría decirse que el uso más comun de los datos de transcriptoma es la busqueda de genes expresados diferencialmente. Encontrar que genes se expresan diferencialmente entre diferentes condiciones es una parte integral en la comprensión de las bases moleculares de la variación fenotípica.\nUn gran número de métodos computacionales se han desarrollado para el análisis de expresión diferencial que difieren ligeramente en su métodología."
  },
  {
    "objectID": "rnaseq/deseq/introduccion.html#deseq2",
    "href": "rnaseq/deseq/introduccion.html#deseq2",
    "title": "Análisis de expresión diferencial",
    "section": "1 DESeq2",
    "text": "1 DESeq2\nDESeq2 (Differential gene expression analysis based on the negative binomial distribution) es un paquete de bioconductor ampliamente utilizado en este tipos de análisis.\nEl punto de partida en el análisis en las matriz de cuentas, siendo el objetivo identificar los genes que estan diferencialmente expresados entre las muestras.\n\n\n\n\n\nDESeq2 comienza estimando los factores de escala, a continuación estima la dispersión de los genes. Por ultimo, DESeq2 ajusta un modelo linear generalizado y genera la lista de genes diferencialmente expresados.\n\n1.1 Estimación del factor de tamaño.\nDESeq2 actua sobre una matriz de cuentas (cuentas no normalizadas). Se supone que las cuentas reflejan la abundacia de genes, pero estas tambien dependen de otros factores como la longitud del gen, los sesgos de secuenciación o la composición de la biblioteca.\n\n1.1.1 Longitud del gen\n\nComo se observa en la figura el gen 1 y el 2 tienen similares niveles de expresión, pero muchas más lecturas se asignan al gen 2, esto podría no tener relación con la biología y podría reflejar unicamente el hecho de que el gen 2 es mas largo que el gen 1. Para el análisis de expresión diferencial, como los niveles de expresión se comparan entre muestras (y no los niveles de expresión entre los genes de una misma muestra), no es recomendable su uso para estimar el factor de tamaño.\n\n\n1.1.2 Profundidad de secuenciación.\nLos experimentos de secuenciación producen decenas de millones de lecturas. Una parte de las lecturas de secuenciación se descartaran durante los procesos de control de calidad, alineación y conteo, lo que implica que el número total de lecturas para cada muestra será diferente.\n\nComo se muestra en la figura, todos los genes parecen ser expresados a un nivel mayor en la muestra 1 que en la muestra 2. Probablemente es debido a que la muestra 1 tiene muchas más lecturas que la muestra 2.\n\n\n1.1.3 Composición de la librería\n\nImaginemos que una celula expresa unicamente 2 genes (gen 1 y gen 2) y asumamos que un tratamiento con un fármaco induce una fuerte expresión del gen 3. Si la normalización se realiza usando unicamente el número total de cuentas, entonces las cuentas del gen 1 se dividirían por 15 en las celulas control, mientras que serían divididas por 165 en las celulas tratadas, lo que nos llevaría a la conclusión erronea de que el tratamiento ha reducido 11 veces la expresión del gen 1. La composición de la libreria ha cambiado pero no el nivel de expresión del gen 1.\nEn un caso real, unos pocos genes expresados de forma muy diferencial, diferencias en el número de genes expresados entre muestras o la presencia de contaminantes pueden sesgar la composición de la librería.\n\n\n1.1.4 El método de normalización de DESeq2\nDESeq2 estima los factores de tamaño teniendo en cuentra el tamaño de la librería y su composicion, usando el método de la mediana de los ratios\n\nPaso 1: DESeq2 crea una muestra de pseudo-referencia calculando la média geométrica por cada gen.\nPaso 2: Por cada gen en cada muestra, se calcula la relación cuentas/pseudo-referencia.\nPaso 3: El valor de la mediana de todas los ratios calculados para una muestra es tomado como el factor de tamaño para esa muestra.\nPaso 4: Los valores normalizados se obtienen dividiendo los valores de las cuentas por el factor de tamaño correspondiente a cada muestra.\n\n\n\n\n1.2 Modelo\nSi observamos la distribucíon de cuentas de una muestra típica en RNA-seq: \nEs obvio que los datos no estan normalmente distribuidos, Los valores son valores enteros y siempre positivos (variable discreta). Podemos observar que hay una gran cantidad de genes con valores muy bajos o cero, y solo unos pocos genes con valores muy altos.\nLos datos de cuentas de RNA-seq se ajustan mejor a una distribución binomial negativa. \\[K_{ij} \\sim NB(mean = µ_{ij},  dispersion = \\alpha_i)\\]\n\n\n1.3 Estimación de la dispersión.\nEstimar la dispersión para cada gen sería sencillo de tener muchas replicas para cada condicion, pero en este caso los experimentos suelen tener a menudo solo 3 replicas. DESeq2 asume que los genes con niveles similares de expresión tendran similar dispersión.\n\nPaso 1: La dispersión de cada gen es estimada por separado. Dado los valores de recuento de las replicas se calcula la dispersión más probable. Los genes con bajos recuentos tienen dispersiones mucho mayores que los genes con mayor nivel de expresión.\nPaso 2: Se ajusta una curva a la dispersión de genes. Los genes tendrán diferente variabilidad biológica, pero en todos los genes habrá una distribución de dispersión razonable.\nPaso 3: Reducción de las estimaciones de la dispersión de los genes hacia los valores predichos por la curva usando el método empírico de Bayes. La reducción de la dispersión es particularmente importante para reducir los falsos positivos en el análisis de expresión diferencial. .\n\n\n\n1.4 Modelo linear generalizado.\nDESeq2 ajusta un modelo linear generalizado de la forma: \\[log2(q_{ij}) = \\Sigma x_j.β_i\\]\nEn el caso de un diseño simple con una condicion (un tratamiento por ejemplo), el modelo se puede escribir como: \\[log2(q_{ij}) = \\beta_0 + \\beta_1.x_j + \\epsilon\\] _0$ es el log2 del nivel de expresion in las muestras control\n\\(\\beta_1\\) es el log2FC entre celulas tratadas y control\n\\(x_j\\) = 0 si la muestra j es de tipo control\n\\(x_j\\) = 1 si la muestra j es de tipo muestra tratada.\n\n\n1.5 Hipótesis\nLa hipótesis nula \\(H_0\\) es que no hay expresión diferencial entre los grupos, lo que equivale a decir que log2FC = 0. La prueba de Wald determinará si los datos proporcionan suficiente evidencia para concluir que este valor es realmente diferente de cero.\n\n\n1.6 Corrección de pruebas multiples\nUn valor de p de 0.05 significa que sólo hay un 5% de posibilidades de obtener estos datos si no existe una diferencia real, es decir, hay un 5% de posibilidades de que se tome una decision equivocada (un falso positivo).\nEn un análisis de RNA-seq podríamos tener 20000 genes y solo una fracción de ellos se expresan de manera diferencial. Supongamos un tratamiento que modifica la expresión de 1000 genes.  El primer histograma de la figura muestra los valores de p para los genes verdaderamente modificados, el segundo histograma muestra la distribución de los valoras de p para los genes no modificados. Los valores se distribuyen uniformemente entre 0 y 1. Podemos ver que el 5% de estos genes parecen significativos, aunque es sólo por casualidad. De 19000 genes 950 falsos positivos. Por lo tanto los valores de la prueba de Wald deben de corregirse para evitar un exceso de falsos positivos. Por defecto DESeq2 usa el método de Benjamini-Hochberg para ajustar los valores de p.\n\n\n1.7 Filtrado independiente\nLos genes con muy pocas cuentas tipicamente son no significantes debido a su alta dispersión. Sin embargo estos genes influyen en la correción de pruebas multiples, mejorando la resolución si estos genes son eliminados. DESeq2 usa como criterio de filtrado la media de las cuentas normalizadas. Los genes con un valor de expresion media inferior a cierto umbral son eliminados. El umbral usado es definido automaticamente por el softeare. Se elige maximizando el número de genes que tendrían un valor de p ajustado significativo.\n\n\n1.8 Referencias\n\nLaurent Gatto and Axelle Loriot. UCLouvain-CBIO/WSBIM2122: Omics data analysis. https://github.com/UCLouvain-CBIO/WSBIM2122.\n\n\nHarvard Chan Bioinformatics Core (HBC). https://hbctraining.github.io/DGE_workshop/"
  },
  {
    "objectID": "rnaseq/deseq/ejemplo.html",
    "href": "rnaseq/deseq/ejemplo.html",
    "title": "Caso practico",
    "section": "",
    "text": "Para este análisis se usarán varios paquetes de R algunos de los cuales han sido instalados desde los repositorios CRAN y otro de los de Bioconductor.\nlibrary(DESeq2)\nlibrary(ggplot2)\nlibrary(ggrepel)\nlibrary(pheatmap)\nlibrary(RColorBrewer)\nCódigo funciones\ncreateVolcanoPlot &lt;- function(d, log2fc, fdr, max.overlaps = 15) {\n\n    colors &lt;- c(\"UP\"=\"#FC4E07\", \"none\"=\"#E7B800\", \"DOWN\"=\"#00AFBB\")\n    d$class &lt;- 'none'\n    d$class[d$log2FoldChange &gt;= log2fc & d$padj &lt;= fdr] &lt;- 'UP'\n    d$class[d$log2FoldChange &lt;= -1 * log2fc & d$padj &lt;= fdr] &lt;- 'DOWN'\n    d$gene &lt;- rownames(d)\n    \n    up_num=nrow(d[d$class == \"UP\",])\n    down_num=nrow(d[d$class == \"DOWN\",])\n    p &lt;- ggplot(d, aes(x = log2FoldChange, y = -1 * log10(padj), \n                       shape = class, fill = class, color = class, label = gene)) +\n                geom_point(size = 3) +\n                scale_fill_manual(values = colors) +\n                scale_color_manual(values = c('navy', \"#E7B800\", 'navy')) +\n                scale_shape_manual(values = c(21, 20, 21)) +\n                geom_hline(yintercept = -1 * log10(fdr), linetype=\"dashed\", \n                              color = \"black\", size=0.5) +\n                geom_vline(xintercept=c(-1 * log2fc,log2fc), linetype=\"dashed\", \n                              color = \"black\", size=0.5) +\n                 geom_label_repel(data = d[d$class %in% c('UP', 'DOWN'),],\n                                  size= 4,\n                                  fontface=\"bold\",\n                                  color=\"firebrick\",\n                                  fill = 'white',\n                                  box.padding=unit(1, \"lines\"),\n                                  point.padding=unit(0.5, \"lines\"),\n                                  segment.colour = \"firebrick\", \n                                  segment.size = 0.5, \n                                  segment.alpha = 0.5, \n                                  max.overlaps = max.overlaps) +\n                theme_bw() +\n                theme(legend.position=\"top\") +\n                annotate(geom = 'text', label = paste0('UP: ', up_num), \n                         x = Inf, y = Inf, hjust = 1.1, vjust = 1.5) +\n                annotate(geom = 'text', label = paste0('DOWN: ', down_num), \n                         x = -Inf, y = Inf, hjust = -0.1, vjust = 1.5) + \n                labs(color = \"class\")\n    p\n}\n\ncrearHeatMap &lt;-function(datos, metadatos) {\n    pheatmap(as.matrix(datos),\n             scale = 'row',\n             clustering_method = 'ward.D2',\n             cutree_cols =  3,\n             cutree_rows = 2,\n             annotation_col = metadatos,\n             fontsize = 8,\n             color = colorRampPalette(c(\"steelblue\", \"white\", \"firebrick3\"))(100)\n            )\n}"
  },
  {
    "objectID": "rnaseq/deseq/ejemplo.html#análisis-exploratorio-de-los-datos.",
    "href": "rnaseq/deseq/ejemplo.html#análisis-exploratorio-de-los-datos.",
    "title": "Caso practico",
    "section": "1 Análisis exploratorio de los datos.",
    "text": "1 Análisis exploratorio de los datos.\n\n1.1 Cargar datos\nCargamos los datos de la matriz de cuentas sin normalizar:\n\ndf.cts &lt;- read.table(\"data/Mov10_full_counts.txt\", header=T, row.names=1) \n\nhead(df.cts)\n\n\n\nMatriz de cuentas\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMov10_kd_2\nMov10_kd_3\nMov10_oe_1\nMov10_oe_2\nMov10_oe_3\nIrrel_kd_1\nIrrel_kd_2\nIrrel_kd_3\n\n\n\n\n1/2-SBSRNA4\n57\n41\n64\n55\n38\n45\n31\n39\n\n\nA1BG\n71\n40\n100\n81\n41\n77\n58\n40\n\n\nA1BG-AS1\n256\n177\n220\n189\n107\n213\n172\n126\n\n\nA1CF\n0\n1\n1\n0\n0\n0\n0\n0\n\n\nA2LD1\n146\n81\n138\n125\n52\n91\n80\n50\n\n\nA2M\n10\n9\n2\n5\n2\n9\n8\n4\n\n\n\n\n\n\n\nmetadata &lt;- read.table(\"data/Mov10_full_meta.txt\", header=T, row.names=1) \n\nmetadata\n\n\n\nMetadatos\n\n\n\nsampletype\nMOVexpr\n\n\n\n\nMov10_kd_2\nMOV10_knockdown\nlow\n\n\nMov10_kd_3\nMOV10_knockdown\nlow\n\n\nMov10_oe_1\nMOV10_overexpression\nhigh\n\n\nMov10_oe_2\nMOV10_overexpression\nhigh\n\n\nMov10_oe_3\nMOV10_overexpression\nhigh\n\n\nIrrel_kd_1\ncontrol\nnormal\n\n\nIrrel_kd_2\ncontrol\nnormal\n\n\nIrrel_kd_3\ncontrol\nnormal\n\n\n\n\n\n\nEs importante comprobar que los nombres de las muestras coinciden en los dos ficheros y estan en el orden correcto.\n\nall(names(df.cts) %in% rownames(metadata))\n\n[1] TRUE\n\nall(names(df.cts) == rownames(metadata))\n\n[1] TRUE\n\n\n\n\n1.2 DESeq2DataSet\nLo primero que necesitamos es crear un objeto DESeqDataSet. DESeqDataSet es una clase personalizada del paquete DESeq2 de Bioconductor. Esta clase se utiliza para almacenar los datos y calculos necesarios. Para crear este objeto necesitamos la matriz de cuentas, los metadatos y una “formula” para el diseño. La formula especifica la columna(o columnas) en la tabla de metadatos que se quiere utilizar para el análisis. - Nota: Es esencial que el nombre de las muestras coincidan en los dos ficheros y esten en el mismo orden.\n\ndds &lt;- DESeqDataSetFromMatrix(\n                countData = df.cts, \n                colData = metadata, \n                design = ~sampletype\n                )\n\ndds\n\nclass: DESeqDataSet \ndim: 23368 8 \nmetadata(1): version\nassays(1): counts\nrownames(23368): 1/2-SBSRNA4 A1BG ... ZZZ3 tAKR\nrowData names(0):\ncolnames(8): Mov10_kd_2 Mov10_kd_3 ... Irrel_kd_2 Irrel_kd_3\ncolData names(2): sampletype MOVexpr\n\n\n\n\n1.3 Prefiltrado de los datos\nTipicamente las matrices de RNA-seq contienen muchas filas con ceros, y adicionalmente otras con valores muy bajos de cuentas. Es recomendable eliminar los genes que no aportan (o casi no aportan ) informacion. Aquí realizaremos un filtrado para mantener los genes con un recuento de al menos 10 para una cantidad mínima de muestras. El valor de 10 es razonamble para datos de secuenciación Bulk-RNA. Una recomendación para el número mínimo de muestras es especificar el tamaño de grupo más pequeño.\n\nnrow(dds)\n\n[1] 23368\n\nsmallestGroupSize &lt;- 2\nkeep &lt;- rowSums(counts(dds) &gt;= 10) &gt;= smallestGroupSize\ndds &lt;- dds[keep,]\nnrow(dds)\n\n[1] 15365\n\n\n\n\n1.4 Normalización de las cuentas\nEn DESeq2 la normalización se calcula usando el metodo de la mediana de las relaciones.\n\ndds &lt;- estimateSizeFactors(dds)\n\ndds\n\nclass: DESeqDataSet \ndim: 15365 8 \nmetadata(1): version\nassays(1): counts\nrownames(15365): 1/2-SBSRNA4 A1BG ... ZZEF1 ZZZ3\nrowData names(0):\ncolnames(8): Mov10_kd_2 Mov10_kd_3 ... Irrel_kd_2 Irrel_kd_3\ncolData names(3): sampletype MOVexpr sizeFactor\n\n\n\n\n1.5 Transformacion cuentas\nLos métodos estadísticos para análisis exploratorio funcionan mejor con datos que tienen similares rangos de varianza a diferentes rangos de medias. En el caso de las cuentas de RNA-seq la varianza crece con la media, con lo cual el PCA estará influenciado por los genes con numeros de cuentas altos. La estrategía para evitarlo es tomar el logaritmo de las cuentas normalizadas sumandole una pseudocuenta (para los casos de 0 cuentas, el log de 0 es indefinido). Sin embargo, ahora los genes con pocas cuentas pueden dominar los resuldatos. DESeq2 usa una transformación logaritmica regularizada como solucion. Para los genes con valores altos el resultado es similar a la transfomación logaritmica log2. Para los genes con valores pequeños los valores se reducen hacia la media de los genes a lo largo de todas las muestras.\n\nrld &lt;- rlog(dds, blind = TRUE)\n\nrld\n\nclass: DESeqTransform \ndim: 15365 8 \nmetadata(1): version\nassays(1): ''\nrownames(15365): 1/2-SBSRNA4 A1BG ... ZZEF1 ZZZ3\nrowData names(7): baseMean baseVar ... dispFit rlogIntercept\ncolnames(8): Mov10_kd_2 Mov10_kd_3 ... Irrel_kd_2 Irrel_kd_3\ncolData names(3): sampletype MOVexpr sizeFactor\n\n\n\n\n1.6 Evaluación de calidad\n\n1.6.1 Análisis de componentes principales (PCA)\nUna manera de visualizar las distancias muestra a muestra es el PCA.\n\nplotPCA(rld, intgroup=c('sampletype'))\n\n\n\n\n\n\n\nFigure 1: Análisis de componentes principales\n\n\n\n\n\n\n\n1.6.2 Clustering jerarquico\nOtra metodo es agrupar las muestras basadas en su similitud. En este caso se puede usar la correlación de Pearson para medir la silitud entre muestras. Generealmente se espera una correlación bastante alta (&gt;0.95) entre todas las muestras, además se esperan ver las muestras agrupadas de manera similar a lo observado en el PCA.\nLas muestras que muestran valores bajos de correlación con las demas muestras (&lt;0.80) representan outliers.\n\n# Estraemos la matix rlog del objeto\nrld_mat &lt;- assay(rld) \n\n# Calculamos las correlaciones\nrld_cor &lt;- cor(rld_mat)\n\n#heatmap\npheatmap(rld_cor, color =  brewer.pal(6, \"Blues\"))\n\n\n\n\nMatriz de correlaciones entre las muestras."
  },
  {
    "objectID": "rnaseq/deseq/ejemplo.html#deseq2",
    "href": "rnaseq/deseq/ejemplo.html#deseq2",
    "title": "Caso practico",
    "section": "2 DESeq2",
    "text": "2 DESeq2\nPara realizar el calculo ejecutamos la funcion DESeq(), que requiere como input un objeto del tipo DESeqDataSet (la variable dds). Reasignando el resultado a la misma variable continuamos llenando los slots del objeto DESeqDataSet.\n\ndds &lt;- DESeq(dds)\n\nusing pre-existing size factors\n\n\nestimating dispersions\n\n\ngene-wise dispersion estimates\n\n\nmean-dispersion relationship\n\n\nfinal dispersion estimates\n\n\nfitting model and testing\n\ndds\n\nclass: DESeqDataSet \ndim: 15365 8 \nmetadata(1): version\nassays(4): counts mu H cooks\nrownames(15365): 1/2-SBSRNA4 A1BG ... ZZEF1 ZZZ3\nrowData names(26): baseMean baseVar ... deviance maxCooks\ncolnames(8): Mov10_kd_2 Mov10_kd_3 ... Irrel_kd_2 Irrel_kd_3\ncolData names(3): sampletype MOVexpr sizeFactor"
  },
  {
    "objectID": "rnaseq/deseq/ejemplo.html#wald-test",
    "href": "rnaseq/deseq/ejemplo.html#wald-test",
    "title": "Caso practico",
    "section": "3 Wald test",
    "text": "3 Wald test\nLa función results() devuelve los valores de log2 fold changes y los p-values para el Wald test de la comparación.\n\nres &lt;- results(dds, contrast = c('sampletype', 'MOV10_overexpression', 'control'))\n\nhead(as.data.frame(res))\n\n\n\nFC y valores p\n\n\n\n\n\n\n\n\n\n\n\n\nbaseMean\nlog2FoldChange\nlfcSE\nstat\npvalue\npadj\n\n\n\n\n1/2-SBSRNA4\n45.67985\n0.3753332\n0.2597951\n1.4447276\n0.1485344\n0.2442718\n\n\nA1BG\n61.13287\n0.2664358\n0.2195424\n1.2135962\n0.2249020\n0.3369021\n\n\nA1BG-AS1\n175.74157\n-0.0562199\n0.1362360\n-0.4126656\n0.6798516\n0.7715430\n\n\nA2LD1\n89.65925\n0.4218562\n0.1922733\n2.1940443\n0.0282322\n0.0630414\n\n\nA4GALT\n64.59690\n1.0013568\n0.2160868\n4.6340497\n0.0000036\n0.0000241\n\n\nAAAS\n1454.28689\n-0.0430074\n0.0680939\n-0.6315892\n0.5276553\n0.6432932\n\n\n\n\n\n\n\nas.data.frame(mcols(res, use.names = TRUE))\n\n\n\nDescripción de los resultados\n\n\n\n\n\n\n\n\ntype\ndescription\n\n\n\n\nbaseMean\nintermediate\nmean of normalized counts for all samples\n\n\nlog2FoldChange\nresults\nlog2 fold change (MLE): sampletype MOV10_overexpression vs control\n\n\nlfcSE\nresults\nstandard error: sampletype MOV10 overexpression vs control\n\n\nstat\nresults\nWald statistic: sampletype MOV10 overexpression vs control\n\n\npvalue\nresults\nWald test p-value: sampletype MOV10 overexpression vs control\n\n\npadj\nresults\nBH adjusted p-values\n\n\n\n\n\n\n\nNota: Algunos valores de p pueden aparecer como NA en la tabla de resultados, esto puede ser debido a que baseMean pueda ser cero, que una fila contenga un valor considerado outlier, o que esa fila sea filtrada por el filtro independiente."
  },
  {
    "objectID": "rnaseq/deseq/ejemplo.html#genes-diferencialmente-expresados",
    "href": "rnaseq/deseq/ejemplo.html#genes-diferencialmente-expresados",
    "title": "Caso practico",
    "section": "5 Genes diferencialmente expresados",
    "text": "5 Genes diferencialmente expresados\nPara selecionar los genes diferecialmente expresados debemos fijar el umbral. En este caso elegimos un FC = 1.5 y un valor de p ajustado de 0.05\n\n#|label: DGE\n\npadj.cutoff &lt;- 0.05\nlfc.cutoff &lt;- log2(1.5)\n\ndf.ashr &lt;- as.data.frame(resLFC)\n\ngenes.ashr.up &lt;- rownames(df.ashr[df.ashr$log2FoldChange &gt;= lfc.cutoff & df.ashr$padj &lt;= padj.cutoff, ])\ngenes.ashr.down &lt;- rownames(df.ashr[df.ashr$log2FoldChange &lt;= -1 * lfc.cutoff & df.ashr$padj &lt;= padj.cutoff, ])\n\nhead(genes.ashr.up)\n\n[1] \"A4GALT\"  \"ABCA1\"   \"ABHD14B\" \"ABL2\"    \"ACADVL\"  \"ACAN\"   \n\nhead(genes.ashr.down)\n\n[1] \"ABCA9\"    \"ACTBL2\"   \"ACTL8\"    \"ACTR3B\"   \"ADAMTS16\" \"ADH1C\"   \n\n\n\n5.1 Volcano plot\n\ncreateVolcanoPlot(df.ashr, lfc.cutoff, padj.cutoff, max.overlaps = 30)\n\n\n\n\nVolcano plot (MOV10_overexpression vs control)\n\n\n\n\n\n\n5.2 Heatmap\nHeatmap de los genes diferecialmente expresados.\n\ndf.norm &lt;- counts(dds, normalized = TRUE)\n\ndf.dge &lt;- df.norm[rownames(df.norm) %in% c(genes.ashr.up, genes.ashr.down), ]\n\ncrearHeatMap(df.dge, metadata)\n\n\n\n\nHeatmap"
  },
  {
    "objectID": "rnaseq/deseq/ejemplo.html#contracción-de-los-fc-para-visualización-y-clasificación.",
    "href": "rnaseq/deseq/ejemplo.html#contracción-de-los-fc-para-visualización-y-clasificación.",
    "title": "Caso practico",
    "section": "4 Contracción de los FC para visualización y clasificación.",
    "text": "4 Contracción de los FC para visualización y clasificación.\nLa reducción del tamaño del efecto (estimaciones de LFC) es útil para la visualización y clasificación de genes\n\nresultsNames(dds)\n\n[1] \"Intercept\"                                 \n[2] \"sampletype_MOV10_knockdown_vs_control\"     \n[3] \"sampletype_MOV10_overexpression_vs_control\"\n\n\n\nresLFC &lt;- lfcShrink(dds, coef=\"sampletype_MOV10_overexpression_vs_control\", type=\"ashr\")\n\nhead(as.data.frame(resLFC))\n\n\n\nFC y valores p\n\n\n\n\n\n\n\n\n\n\n\nbaseMean\nlog2FoldChange\nlfcSE\npvalue\npadj\n\n\n\n\n1/2-SBSRNA4\n45.67985\n0.1868058\n0.1902838\n0.1485344\n0.2442718\n\n\nA1BG\n61.13287\n0.1510142\n0.1684756\n0.2249020\n0.3369021\n\n\nA1BG-AS1\n175.74157\n-0.0423753\n0.1183626\n0.6798516\n0.7715430\n\n\nA2LD1\n89.65925\n0.2728795\n0.1627217\n0.0282322\n0.0630414\n\n\nA4GALT\n64.59690\n0.7830021\n0.2372903\n0.0000036\n0.0000241\n\n\nAAAS\n1454.28689\n-0.0396237\n0.0653723\n0.5276553\n0.6432932"
  },
  {
    "objectID": "rnaseq/deseq/ejemplo.html#referencias",
    "href": "rnaseq/deseq/ejemplo.html#referencias",
    "title": "Caso practico",
    "section": "6 Referencias",
    "text": "6 Referencias\n\nhttps://bookdown.org/ggiaever/2024_RNA-seq-analysis/\n\n\nhttps://bioconductor.org/packages/release/bioc/html/DESeq2.html"
  },
  {
    "objectID": "enrfun/introduccion.html",
    "href": "enrfun/introduccion.html",
    "title": "Enriquecimiento Funcional",
    "section": "",
    "text": "La interpretación de una lista de genes diferencialmente expresados suele ser más util en terminos de vías biológicas.\nDado que los genes actuan colectivamente, un modelo más cercano a la biológia subyacente es aquel en el que las vías biológicas son las que se expresan diferencialmente.\nUna aproximación sería intentar hacer el análisis de expresión diferencial directamente a nivel de vía biológica, o indirectamente buscando la sobrerepresentación de los genes diferencialmente expresados en cada vía de interes.\nBases de datos como Reactome o KEGG anotan información de la literatura sobre los genes y las reacciones que forman las vías biológicas. Otras bases de datos como The Gene Ontology (GO) y Molecular Signatures Database (MSigDB) definen las vías biológicas en terminos de conjuntos de genes."
  },
  {
    "objectID": "enrfun/introduccion.html#vías-biológicas-diferencialmente-expresadas",
    "href": "enrfun/introduccion.html#vías-biológicas-diferencialmente-expresadas",
    "title": "Enriquecimiento Funcional",
    "section": "1 Vías biológicas diferencialmente expresadas",
    "text": "1 Vías biológicas diferencialmente expresadas\nPara encontras estas vía diferencialmente expresadas en terminos de conjunto de genes diferencialmente expresados, es detectanto un enriquecimiento funcional:\n\nBuscar genes diferencialmente expresados (DE).\nPara cada conjunto de genes, verificar si estos genes DE pertenecen a ese conjunto en una proporcion que excede la expectativa de encontrarlo solo por azar.\n\nEn el caso de que un conjunto de genes contiene más genes DE que los que se podrían esperar por puro azar, decimos que este conjunto de genes esta enriquecido en genes DE"
  },
  {
    "objectID": "enrfun/introduccion.html#la-prueba-exacta-de-fisher",
    "href": "enrfun/introduccion.html#la-prueba-exacta-de-fisher",
    "title": "Enriquecimiento Funcional",
    "section": "2 La prueba exacta de Fisher",
    "text": "2 La prueba exacta de Fisher\nLa forma de valorar si un conjunto de genes esta enriquecido o no es a traves de la prueba exacta de Fisher (prueba hipergeométrica)"
  },
  {
    "objectID": "enrfun/introduccion.html#análisis-de-sobrerepresentación-ora",
    "href": "enrfun/introduccion.html#análisis-de-sobrerepresentación-ora",
    "title": "Enriquecimiento Funcional",
    "section": "2 Análisis de sobrerepresentación (ORA)",
    "text": "2 Análisis de sobrerepresentación (ORA)\nLa forma de valorar si un conjunto de genes esta enriquecido o no es a traves de la prueba exacta de Fisher (prueba hipergeométrica). La prueba es útil para los datos categóricos que resultan de clasificar los objetos en dos formas diferentes. Se utiliza para examinar la significación de la asociación entre los dos tipos de clasificación. En nuestro caso si un gen es DE o no dentro de un conjunto de genes.\nEl valor de p se calcula con la función de distribución hipergeométrica. \\[ \\textrm{Pr}(X &gt;= k)=\\sum_{x=k}^{\\textrm{min}(m, n)} \\frac{ {m\\choose x} {N-m\\choose n-x} }{ {N\\choose n} }\\,. \\]\n\nN: Número total de genes (background).\nm: Número de genes en la distribución que estan anotados en el conjunto de genes de interes.\nn: Tamaño de la lista de genes de interes.\nk: Número de genes de la lista que estan anotados en el conjunto de genes.\n\nEjemplo: Supongamos que tenemos 17980 genes detectados en un estudio de RNA-seq, y 57 genes estan diferencialmente expresados. Entre estos 28 estan anotados en un conjunto de genes.\n\n\n\n\n\n\n\ngene.not.interest\ngene.in.interest\n\n\n\n\nIn_category\n2613\n28\n\n\nnot_in_category\n15310\n29\n\n\n\n\n\n\n\n\n\n    Fisher's Exact Test for Count Data\n\ndata:  df\np-value = 1\nalternative hypothesis: true odds ratio is greater than 1\n95 percent confidence interval:\n 0.110242      Inf\nsample estimates:\nodds ratio \n 0.1767937"
  },
  {
    "objectID": "enrfun/introduccion.html#análisis-de-gene-ontology",
    "href": "enrfun/introduccion.html#análisis-de-gene-ontology",
    "title": "Enriquecimiento Funcional",
    "section": "3 Análisis de Gene Ontology",
    "text": "3 Análisis de Gene Ontology\nEs un análisis de enriquecimiento funcional aplicado a cada uno de los conjuntos de genes de la base da datos de GO Gene Ontology (GO) es una representación estructurada y estandarizada del conocimiento biológico. GO describe conceptos, tambien conocidos como términos, que estan interconectados a traves de relaciones definidas formalmente. GO esta diseñado para ser independiente de la especie.\n\n3.1 Ontologías\nUn término GO pertenece a una de las siguientes tres ontologías: Biological Process (BP), Molecular Function (MF) y Cellular Component (CC).\nEl producto de un gen puede asociarse con o localizarse en una o más componentes celulares y estar activo en uno o más procesos biológicos durante los cuales realiza una o más funciones moleculares.\nDentro de una ontología los términos GO estan relacionados unos con otros a través de relaciones jerarquicas que describen cuando un término GO es más general o nó."
  },
  {
    "objectID": "enrfun/introduccion.html#análisis-de-enriquecimiento-de-conjuntos-de-genes-gsea",
    "href": "enrfun/introduccion.html#análisis-de-enriquecimiento-de-conjuntos-de-genes-gsea",
    "title": "Enriquecimiento Funcional",
    "section": "4 Análisis de enriquecimiento de conjuntos de genes (GSEA)",
    "text": "4 Análisis de enriquecimiento de conjuntos de genes (GSEA)\nEl análisis de enriquecimiento ORA se basa en los genes identificados como diferencialmente expresados. Pero tiene la limitación de que necesita una lista minimamente grande de genes. Existen contextos donde los cambios de expresión diferencial puede ser pequeña. Los cambios moleculares más relevantes, si bien pequeños, ocurren de forma coordinada en una misma vía biológica. En estos contextos el método ORA suele fallar.\nGSEA aborda directamente esta limitación. Todos los genes se pueden utilizar en GSEA (y no solamente los genes DE), esto hace posible detectar situaciones donde todos los genes en el conjunto predefinido cambian un poco pero de manera coordinada.\nEn GSEA los genes se clasifican segun su fenotipo, Dado un conjunto de genes S definido a priori, el objetivo de GSEA es determinar si los miembros de S se distribuyen aleatoriamente en toda la lista de genes clasificados (L) o se encuentran principalmente en la parte superior o inferior.\n\n\n\n\n\nHay tres elementos claves en GSEA:\n\nEnrichment Score (ES): representa el grado al cual el conjunto S esta sobrerepresentado an la parte superior o inferior de la lista de genes clasificados L.\nNivel de significancia de ES: el valor de p es calculado mediante permutaciones.\nAjuste para pruebas multiples."
  }
]